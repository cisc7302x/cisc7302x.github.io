[{"id":0,"href":"/docs/home/","title":"Course Information","section":"Docs","content":" Goals # To Build a fully functional general purpose computer from the ground up.\nThe course will be divided into two halves:\nHardware stack: nand gate -\u0026gt; assembler\nElectronic circuits Boolean algebra Logic Gates (digital primitives) Arithmetic Logic Units (combinational circuits) Registers and Memory (sequential circuits) Von Neumann Architecture An Assembler Software stack: virtual machine -\u0026gt; operating sytem\nMaterials # Hardware Description Language Online Simulator Nand 2 Tetris Course on Youtube Nand 2 tetris Home page The Elements of Computing Sytems Text Book Grading # 7-10 Projects\u0026hellip;\u0026hellip;\u0026hellip; 25% Midterm \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 30% (around half way thru) Final \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 45% (cumulative) Attendance \u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;. MANDATORY Calendar # Final exams Dec 16-22th\nCLASS MONTH DAY HW Due 1 Aug 28th 2 Sep 4th 3 Sep 11th Project 1 4 Sep 18th Project 2 5 Sep 25th Project 3 NC Oct 2nd 6 Oct 9th 7 Oct 16th 8 Oct 23rd 9 Oct 30th 10 Nov 6th 11 Nov 13th 12 Nov 20th NC Nov 27th 13 Dec 4th 14 Dec 11th "},{"id":1,"href":"/docs/concepts/interfaces_implementations/","title":"Interfaces and Implementation","section":"Concepts","content":"INTERFACES and IMPLEMENTATIONS\nThis course is NOT really about computers. It\u0026rsquo;s about a method of engineering that allows us to build complex systems, by combining primitives into functional units or modules, and the ability to make those modules usable/reusable without the user knowing how they work, just that they do work.\nAs programmers the ability to build these kinds of modules is one of the most important tools we have for controlling complexity and building complex systems whose bounds that are limited only by our imagination.\nWe call this process BLACK BOX ABSTRACTION.\nblack box abstraction\nThe idea of black box abstraction is to take some PRIMITIVE objects and COMBINE them into FUNCTIONAL REUSABLE NAMED MODULES.\nWe seperate the ideas of the\ninterface: the inputs/outputs into and out of the module. and the way we communicate with the module.\nimplementation: the processing that happens within the module.\nWe build a black box around some functionality and the user only need to think about the inputs/outputs.\nWe seperate:\nWHAT IT IS HOW IT IS DONE. Example # Lets say our friend Harry came over to our house and handed us some modules.\na square root module a addition module Harry\nHarry gives us these module, he doesn\u0026rsquo;t tell us how they find the square root or calculate the sum, just that they do.\nGeorge\nOur friend Goerge comes along and says, I really need to figure out the SUM OF SQUARES can you help me ?\nUs: This is the essence of software engineering.\nWe tell George hold on a second. We go back to the lab and put 2 square root modules and an addition module into a box. We wire it up so the output of each square root are the inputs to the addition and we put the whole thing into a black box and write sum of squares on it.\nWe then have 3 wires sticking out of the black box that says SUM OF SQUARES. The First wire we call A and attach it the input of a square root module. The second wire we call B and attach it the input of the second square root module. Third wire we call output and attach it the output of the addition module.\nAt the end of the day\nWe didn\u0026rsquo;t need to know how Harry made his modules and George didn\u0026rsquo;t need to know how we made ours.\n"},{"id":2,"href":"/docs/concepts/abstraction_layers/","title":"Abstraction Boundaries","section":"Concepts","content":"ABSTRACTION BOUNDARIES\nWe build systems in layers. Each layer is built out of COMBINING PRIMITIVES and NAMING THE COMBINATIONS. We call the interface to a layer ABSTRACTION BOUNDARY.\nA layer HIDES the details of it\u0026rsquo;s own implementation. The user of the layer only needs to rely on the interface to the combinations that have been black boxed at that layer. The set of black boxes that use a particuliar set of primitives form the abstraction boundary for that layer.\nNEW PRIMITIVES\nThe Black Box abstractions from a layer can be used as PRIMITIVES and COMBINED to form new BLACK BOXES and to compose a new layer of functionality. This new layer will also have an abstraction boundary about it.\nLAYER LANGUAGES\nEach layer presents a language for another layer to use. That language is the exposed interface/abstraction boundary for the layer. This a general framework for thinking about languages.\nTHE THREE QUESTIONS\nWe are going to ask these questions about every layer we discuss.\nWhat are the PRIMITIVES ELEMENTS that the language provides ?\nWhat are the MEANS OF COMBINATION of those primitives ? Meaning what mechanism are we using to combine them.\nWhat are the MEANS OF ABSTRACTION ? How do we put a black box around those combinations, so we can use them as modules?\nnaming things One of the greatest powers we have as programmers in our languages is the ability to name things. Naming things, like a function, is one of the most powerfule a means of abstraction.\n"},{"id":3,"href":"/docs/concepts/","title":"Concepts","section":"Docs","content":" Interfaces and Implementation # INTERFACES and IMPLEMENTATIONS\nThis course is NOT really about computers. It\u0026rsquo;s about a method of engineering that allows us to build complex systems, by combining primitives into functional units or modules, and the ability to make those modules usable/reusable without the user knowing how they work, just that they do work.\nAs programmers the ability to build these kinds of modules is one of the most important tools we have for controlling complexity and building complex systems whose bounds that are limited only by our imagination.\nWe call this process BLACK BOX ABSTRACTION.\nblack box abstraction\nThe idea of black box abstraction is to take some PRIMITIVE objects and COMBINE them into FUNCTIONAL REUSABLE NAMED MODULES.\nWe seperate the ideas of the\ninterface: the inputs/outputs into and out of the module. and the way we communicate with the module.\nimplementation: the processing that happens within the module.\nWe build a black box around some functionality and the user only need to think about the inputs/outputs.\nWe seperate:\nWHAT IT IS HOW IT IS DONE. Example # Lets say our friend Harry came over to our house and handed us some modules.\na square root module a addition module Harry\nHarry gives us these module, he doesn\u0026rsquo;t tell us how they find the square root or calculate the sum, just that they do.\nGeorge\nOur friend Goerge comes along and says, I really need to figure out the SUM OF SQUARES can you help me ?\nUs: This is the essence of software engineering.\nWe tell George hold on a second. We go back to the lab and put 2 square root modules and an addition module into a box. We wire it up so the output of each square root are the inputs to the addition and we put the whole thing into a black box and write sum of squares on it.\nWe then have 3 wires sticking out of the black box that says SUM OF SQUARES. The First wire we call A and attach it the input of a square root module. The second wire we call B and attach it the input of the second square root module. Third wire we call output and attach it the output of the addition module.\nAt the end of the day\nWe didn\u0026rsquo;t need to know how Harry made his modules and George didn\u0026rsquo;t need to know how we made ours.\nAbstraction Boundaries # ABSTRACTION BOUNDARIES\nWe build systems in layers. Each layer is built out of COMBINING PRIMITIVES and NAMING THE COMBINATIONS. We call the interface to a layer ABSTRACTION BOUNDARY.\nA layer HIDES the details of it\u0026rsquo;s own implementation. The user of the layer only needs to rely on the interface to the combinations that have been black boxed at that layer. The set of black boxes that use a particuliar set of primitives form the abstraction boundary for that layer.\nNEW PRIMITIVES\nThe Black Box abstractions from a layer can be used as PRIMITIVES and COMBINED to form new BLACK BOXES and to compose a new layer of functionality. This new layer will also have an abstraction boundary about it.\nLAYER LANGUAGES\nEach layer presents a language for another layer to use. That language is the exposed interface/abstraction boundary for the layer. This a general framework for thinking about languages.\nTHE THREE QUESTIONS\nWe are going to repeatedly ask these three questions throughout the semester. We are goint to build a computer in layers and each layer has it\u0026rsquo;s own language.\nWhat are the PRIMITIVES ELEMENTS that the language provides ?\nWhat are the MEANS OF COMBINATION of those primitives ? Meaning what mechanism are we using to combine them.\nWhat are the MEANS OF ABSTRACTION ? How do we put a black box around those combinations, so we can use them as modules?\nnaming things One of the greatest powers we have as programmers in our languages is the ability to name things. Naming things, like a function, is one of the most powerfule a means of abstraction.\nElectronic Circuits # THE PRIMITIVES IN ELECTRONICS\nelectric motive force magnetism conductors: materials that allow electricity to flow resistors: materials that resist the flow of electricity THE MEANS OF COMBINATIONS Different Materials have varying amounts of the above primitive properites. These materials are combined to form electrical components. Some of these are.\ncapacitors resistors transformers transistors (silicon) copper wire insulation FURTHER COMBINATIONS\nThe components above are combined to form circuits. Our concern is digital circuits.\nBoolean Algebra # Intro # Computers are built on primitive electronics (transistors) that output 1 of 2 values.\nThe entire edifice of computer systems is built on expressing boolean alegebraic operations using these electronics as boolean primitives.\nBoolean vlaues # we call them 0 and 1 but you can use 1, 0 A,B red,black on, off t , nil t and false\nBoolean Values (0, 1)\nboolean (operartor/functions) # AND -\u0026gt; only outputs 1 if both inputs are 1 OR -\u0026gt; outputs 1 if either or both inputs are 1 NOT -\u0026gt; outputs the opposite of the input\nNotice each function has a single output and 1 or 2 inputs\nwe can specify the input output relationships using truth tables\nBoolean functions can be combined to form new functions. # IE.\n(not (or nil (and t t)))\nyou can build the truth table for the combination as well. Given inputs x and y. The idea is enumerate every possilbe input and then calculate the output.\nx y (not (or nil (and t t))) 0 0 1 0 1 1 1 0 1 1 1 0 By combining logic operators we create new operators. If you notice this is actually the Negation of the AND operator which happens to be the NAND operator(not and). thus we can simplify the combination to: (not (and x y))\nboolean functions of more than 2 inputs. # I like to write my boolean functions with in prefix notation you can write in prefix or infix.\nf(x,y,z) = (or (and x y) (and z (not x)) )\nwe can build the truth table again by enumerating all possible inputs and determining the outputs. notice for n inputs there are 2^n possilbe input combinations.\ninput output\nx y z (or (and x y) (and z (not x)) ) 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 1 0 1 1 1 1 1 The truth table and the boolean function are 2 different ways of describing the same boolean function.\nBoolean language # Whenever somebody tells you they have a very good language to work with you need to ask them these questions.\nWhat are the primitives ? what are the means of combinations? what are the means of abstraction ?\nBoolean Language. Primtives -\u0026gt; state 0 and state 1 means of cominations -\u0026gt; boolean operators means of abstractionb -\u0026gt; giving names to boolean functions/truth tables\nBoolean Identities # There a properites that we know of from basic elementary school mathamatics that magically also apply to the language of boolean algebra. These can be used to manipulate and simplify boolean expressions.\ncommutative law # (and x y) equals (and y x) (or x y) equals (or y x)\nassociative law # (and x (and y z)) equals (and (and x y) z) (or x (or y z)) equals (or (or x y) z)\ndistibributive law # (or x (and y z)) equals (and (or x y) (or x z)) (and x (or y z)) equals (or (and x y) (and x z))\ndemorgans law (the not distributes to the operator and the values # (not (and x y)) equals (or (not x) (not y)) (not (or x y)) equals (and (not x) (not y))\nwe can prove all these laws just by verifying the left and right hand side aboves all produce the same truth tables for all possible inputs.\nsimplifying booleans expressions with algebraic manipulation # A B C (not (and (not x) (not (or x y))))\nuse demorgans law on C -\u0026gt;\nnow we ahve\n(not (and (not x) (and (not x) (not y)) ))\nuse the associative law\n(not (and (and (not x) (not x)) (not Y)))\nidempotence law says take any value w and do (and w w) is equivalent to w in our case w is (not x) so\n(and (not x) (not x)) simplifies to (not x)\nand we are left with\n(not (and (not x) (not y)))\nwe can apply demorgans law again\n(or (not (not x)) (not (not y)))\ndouble negation law says not of (not (not x) is just x.\nso the whole thing\n(not (and (not x) (not (or x y)))) reduced\n(or x y)\nThe ability to apply these kind of reductions operations to boolean expressions can help while programming every in higher level languages to make faster clearer code.\nreducing boolean expressions with truth tables # we can also reduce by just looking at a truth table and see if we can identify it as somthing we already know.\nBoolean Function Synthesis # We will use boolean algebra to help us construct boolean functions from more primitive boolean operations.\nThese functions will ultimately get directly translated into hardware.\nWe can express a boolean function in 2 ways.\na boolean expression a truth table We know how to go from an expression to a truth table: -\u0026gt; evalutate the outpu from all possible inputs to the expression.\nNow we have to figure out how to find and expression from a truth table. # We start with a specification of a function by enumearting inputs and outputs like a truth table. and we need to derive the algebraic expression from this specification.\nWhen we design a computer we have an idead of what inputs and outputs we want and we can write them down. but we need to figure out what the expression is so we can translate into some combinations of electronic components called logic gates which are direct HARDWARE EMBODIMENTS of boolean operators and functions.\ndisjunctive normal form formula # go row by row and find all rows with value of 1.\nfor each row with an output of 1 we construct a boolean function that would only produce a 1 on that row.\nfor example\nx y z out 0 0 0 1 (and (not x) (not y) (not z))\nx y z out 0 1 0 1 (and (not x) y (not z))\nx y z out 1 0 0 1 (and z (not y) (not z))\nIf we combine all these rows with an OR operator we will get an expression that matches the truth table.\n(or (and (not x) (not y) (not z)) (and (not x) y (not z)) (and x (not y) (not z)))\nif we examine the first two clauses we notice that they both are dependent on the value of (not x) and (not z) and they both will return true no matter what y is becuase in one we have y and the other (not y) so we can reduce those 2 expressions to one expression (and (not x) (not z))\nso we end up with (or (and (not x) (not z)) (and x (not y) (not z)))\nThere are many different ways of expressing a function that are equivalent.\nThe problem of reducing a boolean expression to it\u0026rsquo;s simples form is acutally a very a very difficult probelm for humans and computers to solve. It is actually NP complete hard problem.\nboolean function primitives # The important point is here is that than any Boolean Function no matter how complex and no matter how many inputs, can be expressed using only, AND OR NOT. and furthermore we don\u0026rsquo;t even need all of these.\nwe don\u0026rsquo;t need or gates # we really only need AND NOT to express any Boolean function.\nwe have seen that we can express any function with, AND OR NOT\nif We can prove that we can express the OR operator using AND NOT We will be able to then express any function with just AND and NOT operators.\nproof\nwe can do this using demorgans law.\nremember de morgans law (not (and a b)) = (or (not a) (not b))\nwell if we say a is (not x) and b is (not y) we have (not (and (not x) (not y))) = (or (not (not x)) (not (not y))) = (or x y)\nso we have shown we can express an OR operator with the AND and NOT operators.\nNAND FUNCTION # x y out 0 0 1 0 1 1 1 0 1 1 1 0\nwe can create a nand function using NOT and AND (NOT (AND X Y)) = (NAND X Y) recall AND truth table\nx y out 0 0 0 0 1 0 1 0 0 1 1 1\nNAND GATE CAN EXPRESS NOT and AND\nif we can show that we can express NOT and AND with NAND, then we can express and calculate the results of all possible boolean functions with the NAND gate.\n(NAND x x) = (NOT X) proof x y nand (Nand x x) 0 0 1 when x= 0 =\u0026gt; 1 0 1 1 1 0 1 1 1 0 when x =1 =\u0026gt; 0\n(NOT (NAND X Y)) = (AND X Y) proof x y nand not(nand) 0 0 1 0 0 1 1 0 1 0 1 0 1 1 0 1\nLOGIC GATES # LOGIC GATES ARE THE PHYSICAL EMBODIMENT OF Boolean functions/operators in HARDWARE.\nA logic gate is a standalone simple silicon chip that is designed to deliver well defined boolean functionality.\nElementary Logic gate chips provide -\u0026gt; (nand and or out) Compositie Logic gate chips provide -\u0026gt; are made by combining elementary logic gates and/or other composite gates with each other. (multiplexers adders etc\u0026hellip;)\nElementary Gates # the most fundamental gate/chip is the NAND\nThis is the primitive we will be using to build all our other gates.\nneed to show diagram\nfunctional specification if (a==1 and b==1) then out=0 else out=1\ntruth table\na b out 0 0 1 0 1 1 1 0 1 1 1 0 AND Gate OR Gate NOT Gate Composite Gates # 3 input AND gates\nbuilt out of two AND gates\ndiagram\nspecification if (a == 1 and b==1 and c==1) then out=1 else out = 0\nGate interaface and implementation # The black box abstraction around some gate provides an inteface. This is how a Client/User of the gate thinks about WHAT the gate is supposed to do.\nThe client/user does not need to know HOW the gate is implemented. To understand HOW a gate is implemented we need to go to a lower level of detail, we need to open the black box to see what is inside.\nA single unique INTERFACE may be IMPLEMENTED in many different ways.\nneed diagrams from 6:08 day1 of\ninterface implementation circuit implementations-\u0026gt; electrical engineering # this course does not deal with physical circuit implementations, circuits transistors relays, electrical engineering. demo in person ??? necessary?\nwe will be using the logic gate black box abstractions starting with nand gate.\nGATES # Hardware Description Language # Hardware engineers use software to and computer programming language called HDL to design, build and test chips/gates. That is exactly what we are going to do. We will build our projects using an online hardware simulator.\nThe process of building a chip/gate is,\ngiven behavior specs possibly in the form of a truth table draw a diagram, combining the primitives that you were given or had developed previously, in a meaningful way so your have a combination that accomplishes the given spec implement it in HDL Test and implementation against specs "},{"id":4,"href":"/docs/concepts/electronic_circuits/","title":"Electronic Circuits","section":"Concepts","content":"ELECTRONIC CIRCUITS\nWhat are the primitives in electronics # electric motive force magnetism conductors: materials that allow electricity to flow resistors: materials that resist the flow of electricity The means of combinations # Different Materials have varying amounts of the above primitive properites. These materials are combined to form electrical components. Some of these are.\ncapacitors resistors transformers transistors (silicon) copper wire insulation diodes circuits # We use the components above as primitives and combine them into electronic circuits by connecting them together using breadboards, circuit boards, silicon chips, etc.. We use circuits to do work for us.\nHere are some types of circuits we create by combining the primitves from above. These circuits are then used as primitves and combined to form more complex systems. Notice how we name things as a means of abstraction.\nAmplification Circuits # Operational Amplifier (Op-Amp) Configurations:\nInverting Amplifier - Basic signal amplification with phase inversion Non-inverting Amplifier - Signal amplification without phase change Voltage Follower (Buffer) - High input impedance, low output impedance Differential Amplifier - Amplifies difference between two inputs Instrumentation Amplifier - High-precision differential amplification Signal Processing Circuits # Active Filters - Low-pass, high-pass, band-pass, band-stop using op-amps Integrator Circuit - Produces output proportional to integral of input Differentiator Circuit - Output proportional to derivative of input Schmitt Trigger - Hysteresis comparator for noise immunity Peak Detector - Captures and holds maximum input voltage Digital Logic Foundations # Transistor Switches - BJT and MOSFET switching circuits Logic Gates - NAND, NOR implementations using transistors Pull-up/Pull-down Resistors - Ensuring defined logic states Level Shifters - Converting between different voltage domains Power and Regulation # Voltage Divider - Basic voltage scaling Linear Voltage Regulator - Simple voltage regulation (LM7805 family) Switching Regulator - Efficient power conversion (buck, boost) Current Mirror - Precise current copying and scaling Timing and Oscillation # RC/LC Oscillators - Generating periodic signals Crystal Oscillator - Precise frequency generation 555 Timer - Astable and monostable multivibrator configurations Phase-Locked Loop (PLL) - Frequency synthesis and synchronization Interface and Protection # Voltage/Current Limiters - Circuit protection ESD Protection - Electrostatic discharge protection Level Converters - Interface between different logic families Isolation Circuits - Optocouplers, transformers digital circuits # For this course we are interested in digital primitives and the combinations and further abstraction barriers that we form from them. Our fundamental primitive will be a LOGIC GATE. Logic Gates are circuits that are created to replicate the properties of objects from BOOLEAN ALGEBRA.\nThe Transistor # The transistor is the fundamental primitive that allows us to construct gate circuits. It is actually an interface to two of our electronics conduction and resistance.\nA transistors generally has 3 terminals\na collector a emmiter a base In a circuit a transistor acts like a switch. A switch is an electrical device that can\nopen a circuit =\u0026gt; stopping electrical flow close circuit =\u0026gt; allowing electricty to flow A transistor acts as switch but uses electrical signals to open and close the circuit through the collector and transmitter.\nIf there is no current at the base there is 100% resistance no flow of electricity from collector to emitter.\nBut if we put a current at the base, then the it acts as a conductor and electricty flows from collector to emitter.\nHere is an example of simple circuit, we have a manual switch that when open prevents electric flow from getting to the led, but when we manual close it elctricity will flow to the transistor(base) and that will in turn allow electrcity to flow through from colleector to transmittor and on to the LED. Turning the lite on.\nBuilding Logic Gates out of transistors # Digital Logic Gates are a electronic circuits that mimic functions/operators of Boolean Algebra. We build Electronic Logic Gates using transistors.\nLet\u0026rsquo;s name the states of an open and closed circuit as\n0 NO CURRENT FLOWING 1 CURRENT FLOWING AND gate # We can put two transistors in series, that is one after the other\nwhen the current at both bases is 0(no current flow) then the output of the second emitter will also be 0(no current flow).\nBut even if you put a current(1) at the base of the first or second transistor. the output will still be 0 because the other transistor will act as an insulator.\nThe only way current will flow, that is obtain a 1 at the output is for both transistors to act as conductors which happens when there is current at both bases.\nIf we put a black box around these two transistors it will have two inputs and 1 output. The behavior mimics the operator AND in boolean algebra.\nHere is our black box abstraction:\nIn Digital electronics we use the following symbol to represent our black Box abstraction of an AND GATE.\nOR GATE # We can also situate our tranistors in Parrallel if both transistors are acting as insulators then current will not flow.\nHow ever if either transistor acts as a conductor then current will flow througth to the output of the circuit.\nWhen we put a box around this circuit what we have is an OR Gate.\nThis is the symbol we use for an OR gate\nNOT GATE # One more very important primitive gate is called a NOT gate.\ntransistors\n"},{"id":5,"href":"/docs/projects/","title":"Projects","section":"Docs","content":"Homework projects\nwk1 build 15 gates with a primitive (nand gate) # not and or xor Mux Dmux Not16 And16 Or16 Mux16 Or8way Mux4way16 Mux8way16 Dmux4way Dmux8way\nwk2 Build An alu you using the black boxes from last week as primitives # Arithmatic Login unit halfadder fulladder add16 Inc16 ALU wk3 Register and Memory System # Bit Register RAM8 RAM64 RAM512 RAM4k RAM16K Program Counter\nwk4 start to consider the hack machine language # wk5 combine our alu and memory into a computer # wk6 develop an assembly language for our computer. # MIDTERM\n"},{"id":6,"href":"/docs/concepts/boolean_algebra/","title":"Boolean Algebra","section":"Concepts","content":" Intro # Computers are built on primitive electronics (transistors) that output 1 of 2 values.\nThe entire edifice of computer systems is built on expressing boolean alegebraic operations using these electronics as boolean primitives.\nBoolean vlaues # we call them 0 and 1 but you can use 1, 0 A,B red,black on, off t , nil t and false\nBoolean Values (0, 1)\nboolean (operartor/functions) # AND -\u0026gt; only outputs 1 if both inputs are 1 OR -\u0026gt; outputs 1 if either or both inputs are 1 NOT -\u0026gt; outputs the opposite of the input\nNotice each function has a single output and 1 or 2 inputs\nwe can specify the input output relationships using truth tables\nBoolean functions can be combined to form new functions. # IE.\n(not (or nil (and t t)))\nyou can build the truth table for the combination as well. Given inputs x and y. The idea is enumerate every possilbe input and then calculate the output.\nx y (not (or nil (and t t))) 0 0 1 0 1 1 1 0 1 1 1 0 By combining logic operators we create new operators. If you notice this is actually the Negation of the AND operator which happens to be the NAND operator(not and). thus we can simplify the combination to: (not (and x y))\nboolean functions of more than 2 inputs. # I like to write my boolean functions with in prefix notation you can write in prefix or infix.\nf(x,y,z) = (or (and x y) (and z (not x)) )\nwe can build the truth table again by enumerating all possible inputs and determining the outputs. notice for n inputs there are 2^n possilbe input combinations.\ninput output\nx y z (or (and x y) (and z (not x)) ) 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 1 0 1 1 1 1 1 The truth table and the boolean function are 2 different ways of describing the same boolean function.\nBoolean language # Whenever somebody tells you they have a very good language to work with you need to ask them these questions.\nWhat are the primitives ? what are the means of combinations? what are the means of abstraction ?\nBoolean Language. Primtives -\u0026gt; state 0 and state 1 means of cominations -\u0026gt; boolean operators means of abstractionb -\u0026gt; giving names to boolean functions/truth tables\nBoolean Identities # There a properites that we know of from basic elementary school mathamatics that magically also apply to the language of boolean algebra. These can be used to manipulate and simplify boolean expressions.\ncommutative law # (and x y) equals (and y x) (or x y) equals (or y x)\nassociative law # (and x (and y z)) equals (and (and x y) z) (or x (or y z)) equals (or (or x y) z)\ndistibributive law # (or x (and y z)) equals (and (or x y) (or x z)) (and x (or y z)) equals (or (and x y) (and x z))\ndemorgans law (the not distributes to the operator and the values # (not (and x y)) equals (or (not x) (not y)) (not (or x y)) equals (and (not x) (not y))\nwe can prove all these laws just by verifying the left and right hand side aboves all produce the same truth tables for all possible inputs.\nsimplifying booleans expressions with algebraic manipulation # A B C (not (and (not x) (not (or x y))))\nuse demorgans law on C -\u0026gt;\nnow we ahve\n(not (and (not x) (and (not x) (not y)) ))\nuse the associative law\n(not (and (and (not x) (not x)) (not Y)))\nidempotence law says take any value w and do (and w w) is equivalent to w in our case w is (not x) so\n(and (not x) (not x)) simplifies to (not x)\nand we are left with\n(not (and (not x) (not y)))\nwe can apply demorgans law again\n(or (not (not x)) (not (not y)))\ndouble negation law says not of (not (not x) is just x.\nso the whole thing\n(not (and (not x) (not (or x y)))) reduced\n(or x y)\nThe ability to apply these kind of reductions operations to boolean expressions can help while programming every in higher level languages to make faster clearer code.\nreducing boolean expressions with truth tables # we can also reduce by just looking at a truth table and see if we can identify it as somthing we already know.\nBoolean Function Synthesis # We will use boolean algebra to help us construct boolean functions from more primitive boolean operations.\nThese functions will ultimately get directly translated into hardware.\nWe can express a boolean function in 2 ways.\na boolean expression a truth table We know how to go from an expression to a truth table: -\u0026gt; evalutate the outpu from all possible inputs to the expression.\nNow we have to figure out how to find and expression from a truth table. # We start with a specification of a function by enumearting inputs and outputs like a truth table. and we need to derive the algebraic expression from this specification.\nWhen we design a computer we have an idead of what inputs and outputs we want and we can write them down. but we need to figure out what the expression is so we can translate into some combinations of electronic components called logic gates which are direct HARDWARE EMBODIMENTS of boolean operators and functions.\ndisjunctive normal form formula # go row by row and find all rows with value of 1.\nfor each row with an output of 1 we construct a boolean function that would only produce a 1 on that row.\nfor example\nx y z out 0 0 0 1 (and (not x) (not y) (not z))\nx y z out 0 1 0 1 (and (not x) y (not z))\nx y z out 1 0 0 1 (and z (not y) (not z))\nIf we combine all these rows with an OR operator we will get an expression that matches the truth table.\n(or (and (not x) (not y) (not z)) (and (not x) y (not z)) (and x (not y) (not z)))\nif we examine the first two clauses we notice that they both are dependent on the value of (not x) and (not z) and they both will return true no matter what y is becuase in one we have y and the other (not y) so we can reduce those 2 expressions to one expression (and (not x) (not z))\nso we end up with (or (and (not x) (not z)) (and x (not y) (not z)))\nThere are many different ways of expressing a function that are equivalent.\nThe problem of reducing a boolean expression to it\u0026rsquo;s simples form is acutally a very a very difficult probelm for humans and computers to solve. It is actually NP complete hard problem.\nboolean function primitives # The important point is here is that than any Boolean Function no matter how complex and no matter how many inputs, can be expressed using only, AND OR NOT. and furthermore we don\u0026rsquo;t even need all of these.\nwe don\u0026rsquo;t need or gates # we really only need AND NOT to express any Boolean function.\nwe have seen that we can express any function with, AND OR NOT\nif We can prove that we can express the OR operator using AND NOT We will be able to then express any function with just AND and NOT operators.\nproof # we can do this using demorgans law.\nremember de morgans law (not (and a b)) = (or (not a) (not b))\nwell if we say a is (not x) and b is (not y) we have (not (and (not x) (not y))) = (or (not (not x)) (not (not y))) = (or x y)\nso we have shown we can express an OR operator with the AND and NOT operators.\nNAND FUNCTION # x y out 0 0 1 0 1 1 1 0 1 1 1 0\nwe can create a nand function using NOT and AND (NOT (AND X Y)) = (NAND X Y) recall AND truth table\nx y out 0 0 0 0 1 0 1 0 0 1 1 1\nNAND GATE CAN EXPRESS NOT and AND # if we can show that we can express NOT and AND with NAND, then we can express and calculate the results of all possible boolean functions with the NAND gate.\n(NAND x x) = (NOT X) proof x y nand (Nand x x) 0 0 1 when x= 0 =\u0026gt; 1 0 1 1 1 0 1 1 1 0 when x =1 =\u0026gt; 0\n(NOT (NAND X Y)) = (AND X Y) proof x y nand not(nand) 0 0 1 0 0 1 1 0 1 0 1 0 1 1 0 1\nLOGIC GATES # LOGIC GATES ARE THE PHYSICAL EMBODIMENT OF Boolean functions/operators in HARDWARE.\nA logic gate is a standalone simple silicon chip that is designed to deliver well defined boolean functionality.\nElementary Logic gate chips provide -\u0026gt; (nand and or out) Compositie Logic gate chips provide -\u0026gt; are made by combining elementary logic gates and/or other composite gates with each other. (multiplexers adders etc\u0026hellip;)\nElementary Gates # the most fundamental gate/chip is the NAND # This is the primitive we will be using to build all our other gates.\nneed to show diagram\nfunctional specification if (a==1 and b==1) then out=0 else out=1\ntruth table\na b out 0 0 1 0 1 1 1 0 1 1 1 0 AND Gate # OR Gate # NOT Gate # Composite Gates # 3 input AND gates # built out of two AND gates\ndiagram\nspecification if (a == 1 and b==1 and c==1) then out=1 else out = 0\nGate interaface and implementation # The black box abstraction around some gate provides an inteface. This is how a Client/User of the gate thinks about WHAT the gate is supposed to do.\nThe client/user does not need to know HOW the gate is implemented. To understand HOW a gate is implemented we need to go to a lower level of detail, we need to open the black box to see what is inside.\nA single unique INTERFACE may be IMPLEMENTED in many different ways.\nneed diagrams from 6:08 day1 of\ninterface implementation circuit implementations-\u0026gt; electrical engineering # this course does not deal with physical circuit implementations, circuits transistors relays, electrical engineering. demo in person ??? necessary?\nwe will be using the logic gate black box abstractions starting with nand gate.\n"}]